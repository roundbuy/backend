import fs from 'fs';
import translate from 'translate';

// Configure translate engine
translate.engine = 'google';

const KEYS_FILE = '/Users/ravisvyas/Code/roundbuy-new/mobile-app/extracted_keys.json';
const SQL_OUTPUT_FILE = '/Users/ravisvyas/Code/roundbuy-new/backend/migrations/2026-01-23-seed-mobile-translations.sql';

const LANGUAGES = {
    'hi': 'Hindi',
    'es': 'Spanish',
    'fr': 'French',
    'de': 'German',
    'sv': 'Swedish',
    'no': 'Norwegian',
    'is': 'Icelandic',
    'fi': 'Finnish',
    'pl': 'Polish',
    'lv': 'Latvian',
    'lt': 'Lithuanian',
    'bg': 'Bulgarian',
    'ja': 'Japanese',
    'zh-CN': 'Chinese (Mandarin)',
    'zh-TW': 'Chinese (Traditional)',
    'ko': 'Korean',
    'ar': 'Arabic',
    'it': 'Italian',
    'pt': 'Portuguese'
};

const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function main() {
    console.log('Starting translation generation...');

    if (!fs.existsSync(KEYS_FILE)) {
        console.error(`Keys file not found: ${KEYS_FILE}`);
        process.exit(1);
    }

    const keys = JSON.parse(fs.readFileSync(KEYS_FILE, 'utf8'));
    const totalKeys = Object.keys(keys).length;
    console.log(`Loaded ${totalKeys} keys.`);

    let sql = "-- Seed translations for mobile app screens\n";
    sql += "-- Generated by generate_multilingual_sql.mjs using Node translate (Concurrency: 10)\n\n";

    console.log('Generating INSERT statements for keys...');
    sql += "-- 1. Insert Translation Keys\n";
    const entries = Object.entries(keys).sort((a, b) => a[0].localeCompare(b[0]));

    for (const [key, defaultText] of entries) {
        const category = key.includes('.') ? key.split('.')[0] : 'common';
        const safeKey = key.replace(/'/g, "''");
        const safeText = defaultText.replace(/'/g, "''");
        sql += `INSERT INTO translation_keys (key_name, category, default_text) VALUES ('${safeKey}', '${category}', '${safeText}') ON DUPLICATE KEY UPDATE default_text = VALUES(default_text);\n`;
    }

    sql += "\n-- 2. Insert Translations\n";

    const CONCURRENCY = 10;

    for (const [code, name] of Object.entries(LANGUAGES)) {
        console.log(`Processing ${name} (${code})...`);

        let successCount = 0;
        let failCount = 0;

        for (let i = 0; i < entries.length; i += CONCURRENCY) {
            const chunk = entries.slice(i, i + CONCURRENCY);

            await Promise.all(chunk.map(async ([key, defaultText]) => {
                let translatedText = defaultText;

                if (defaultText.trim()) {
                    try {
                        translatedText = await translate(defaultText, { to: code, from: 'en' });
                        successCount++;
                    } catch (error) {
                        translatedText = `[${code.toUpperCase()}] ${defaultText}`;
                        failCount++;
                    }
                }

                const safeKey = key.replace(/'/g, "''");
                const safeTranslated = translatedText.replace(/'/g, "''");
                let dbCode = code;
                if (code === 'zh-TW') dbCode = 'zh-HK';

                sql += `INSERT IGNORE INTO translations (translation_key_id, language_id, translated_text) SELECT id, (SELECT id FROM languages WHERE code = '${dbCode}'), '${safeTranslated}' FROM translation_keys WHERE key_name = '${safeKey}';\n`;
            }));

            process.stdout.write(`\r  Progress: ${Math.min(i + CONCURRENCY, entries.length)}/${entries.length}`);
            await delay(200);
        }
        console.log(`\n  Completed ${name}: ${successCount} translated, ${failCount} failed.`);
    }

    fs.writeFileSync(SQL_OUTPUT_FILE, sql, 'utf8');
    console.log(`\nSuccess! SQL written to: ${SQL_OUTPUT_FILE}`);
}

main().catch(err => {
    console.error('Fatal error:', err);
    process.exit(1);
});
